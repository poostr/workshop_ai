# ADR-0029: Тесты конкурентности и инвариантов move-эндпоинта (QA-002)

## Статус
Принято

## Контекст
Endpoint `POST /api/v1/types/{id}/move` использует пессимистическую блокировку (`SELECT ... FOR UPDATE`) для защиты от отрицательных остатков при параллельных запросах. Базовые тесты из API-005 покрывали только последовательные сценарии. Необходимо подтвердить корректность блокировки при реальной конкуренции.

## Решение

### Подход к тестированию конкурентности
Для эмуляции параллельных HTTP-запросов используется `concurrent.futures.ThreadPoolExecutor`. Каждый поток создаёт собственный `TestClient(app)`, что гарантирует независимые DB-сессии и транзакции через общий пул соединений SQLAlchemy.

Выбран именно этот подход (а не async/httpx или прямые SQLAlchemy-сессии), потому что:
- Тестирует реальный API-контракт (HTTP запрос → ответ), а не внутренности
- Проверяет полный стек: FastAPI → SQLAlchemy → PostgreSQL FOR UPDATE
- Не требует дополнительных зависимостей (pytest-asyncio и т.д.)

### Покрытие тестов
1. **Конкурентность (3 теста)**:
   - Single-unit moves: 20 параллельных запросов на перемещение 1 шт. при 10 доступных → ровно 10 успехов
   - Batch moves: 6 параллельных запросов по 5 шт. при 15 доступных → ровно 3 успеха
   - Multi-stage: конкурентные перемещения из разных стадий не блокируют друг друга (хотя обе используют FOR UPDATE на свои строки)

2. **Инварианты (5 тестов)**:
   - Перемещение точного доступного количества (граница: count → 0)
   - Пропуск промежуточных стадий (IN_BOX → DONE)
   - Отклонение перехода в ту же стадию (from == to)
   - 404 для несуществующего типа
   - Последовательные перемещения через pipeline накапливаются корректно

### Инфраструктурные замечания
- Тесты выполняются в контейнере против реального PostgreSQL (не SQLite)
- Переиспользуется существующая фикстура `database_url` из `conftest.py`
- `_build_session_factory` (lru_cache) корректно работает при shared engine из нескольких потоков — SQLAlchemy engine thread-safe

## Последствия
- Подтверждена корректность пессимистической блокировки: counts не уходят в минус
- Тесты проходят стабильно (не flaky) благодаря детерминированной проверке: ровно N успехов из M запросов
- Общее покрытие backend-тестов: 33 теста
