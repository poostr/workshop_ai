# ADR-0016: Атомарное перемещение по pipeline (API-005)

- Статус: Accepted
- Дата: 2026-02-25
- Связанная задача: API-005

## Контекст

Следующая невыполненная задача этапа C требует реализовать `POST /api/v1/types/{id}/move` для критического сценария изменения остатков по стадиям.

Инварианты проекта:

- перемещение допускается только вперёд по фиксированному pipeline;
- количество в источнике не может уходить в минус;
- обновление счётчиков и запись истории должны происходить атомарно;
- при ошибках бизнес-логики API обязан возвращать код ошибки по контракту.

Также важно не дублировать логику сборки карточки типа в нескольких endpoint'ах.

## Решение

1. Реализовать endpoint `POST /api/v1/types/{id}/move` в `backend/app/api/v1/router.py`:
   - валидировать направление перехода через доменный helper `is_forward_transition`;
   - для строк источника/цели использовать блокировку `SELECT ... FOR UPDATE`;
   - при недостатке остатка возвращать `ERR_INSUFFICIENT_QTY`;
   - при некорректном направлении возвращать `ERR_INVALID_STAGE_TRANSITION`;
   - при успехе обновлять `stage_counts`, писать запись в `history_logs` и коммитить одной транзакцией.
2. Централизовать сборку ответа карточки типа:
   - добавить `_iter_type_rows_by_id` и `_build_type_item_by_id`;
   - переиспользовать этот путь и в `GET /api/v1/types/{id}`.
3. Подтвердить контракт интеграционными тестами:
   - happy path со сменой counts и записью в историю;
   - ошибка при недостатке количества;
   - ошибка при попытке перехода назад.

## Последствия

- Положительные:
  - закрыт критический бизнес-путь перемещения миниатюр;
  - соблюдены инварианты non-negative и forward-only;
  - минимизирован риск race conditions в продовом Postgres-контуре;
  - снижено дублирование в роутере.
- Ограничения:
  - в тестовом sqlite-контуре блокировка `FOR UPDATE` не эмулирует поведение Postgres полностью, поэтому конкурентные сценарии остаются в зоне задач этапа QA.
