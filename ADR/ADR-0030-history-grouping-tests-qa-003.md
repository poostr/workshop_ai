# ADR-0030: Тесты группировки истории — граничные условия (QA-003)

## Статус
Принято

## Контекст
Endpoint `GET /api/v1/types/{id}/history` реализует read-time группировку соседних событий по правилу: одинаковый переход `from→to` и разница между **соседними** событиями ≤ 300 секунд. Базовые тесты из API-006 покрывали сценарий 299/300/301 в составном тесте и кейс «не соседние — не группировать». Требуется расширить покрытие до явных граничных условий и дополнительных edge-case'ов.

## Решение

### Стратегия тестирования
Вместо одного составного теста добавлены **изолированные тесты** на каждую границу, что упрощает диагностику при регрессии:

1. **Exact 300 seconds** (2 события) → одна группа. Подтверждает включённость границы (`<=`).
2. **Exact 301 seconds** (2 события) → две группы. Подтверждает исключённость за границей (`> 300`).
3. **Sliding window** (цепочка по 299с, суммарный span 897с) → одна группа. Подтверждает, что сравнение идёт между соседними событиями, а не относительно начала группы.
4. **Пустая история** → пустой `items`.
5. **Одно событие** → одна группа.
6. **Чередующиеся переходы** → корректное разбиение на группы при смене `from→to`.
7. **Одновременные события** (0 секунд) → группируются.

### Рефакторинг
Вынесен helper `_create_type_and_seed_history` для устранения дублирования создания типа + вставки сырых данных в `history_logs` через прямой SQL. Это позволяет точно контролировать `created_at` без зависимости от системного времени.

### Решение по hardcoded type_id
В SQL-вставках используется `type_id = 1`, поскольку фикстура `database_url` полностью пересоздаёт схему перед каждым тестом (`DROP SCHEMA CASCADE` + Alembic upgrade). Это гарантирует, что autoincrement начинается с 1.

## Последствия
- Покрытие группировки истории расширено с 2 до 9 тестов.
- Общее количество backend-тестов: 40 passed.
- Граничные условия 299/300/301 протестированы как в составном сценарии, так и изолированно.
