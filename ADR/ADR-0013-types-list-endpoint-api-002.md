# ADR-0013: Endpoint списка типов с агрегированными counts (API-002)

- Статус: Accepted
- Дата: 2026-02-25
- Связанная задача: API-002

## Контекст

Для экрана списка типов требуется backend endpoint `GET /api/v1/types` с инвариантами:

- сортировка по имени (`name ASC`);
- наличие агрегированных количеств по всем стадиям;
- отсутствие дублирования бизнес-логики стадий;
- совместимость с текущей моделью хранения (`miniature_types` + `stage_counts`).

На момент старта задачи API содержал только `GET /api/v1/status`, а доступа к БД через DI в роутерах не было.

## Решение

1. Реализовать `GET /api/v1/types` в `backend/app/api/v1/router.py`:
   - использовать `LEFT JOIN` `miniature_types` к `stage_counts`;
   - сортировать на SQL-уровне по `name ASC`, дополнительно стабилизировать `id ASC`;
   - агрегировать rows в API-ответ формата `{"items": [...]}`.
2. Ввести явные response-схемы:
   - `TypeStageCounts`, `TypeListItem`, `TypeListResponse` в `backend/app/api/v1/schemas.py`.
3. Добавить слой DB-зависимости для endpoint’ов:
   - `backend/app/db/session.py` с `get_db_session` (FastAPI dependency) и lazy/cached фабрикой сессий.
4. Зафиксировать поведение интеграционными тестами:
   - пустая БД;
   - сортировка и полнота `counts` (все 5 стадий присутствуют в ответе).

## Последствия

- Положительные:
  - endpoint соответствует контракту PRD/TECHSPEC и готов к использованию фронтендом;
  - API-ответ стабилен и предсказуем для i18n/UI слоя;
  - введён переиспользуемый DI-механизм DB-сессий для следующих задач этапа C.
- Ограничения:
  - текущая реализация формирует `counts` в приложении после SQL-выборки; при росте объёма данных может потребоваться оптимизация read-model (например, JSON-агрегация в SQL).
