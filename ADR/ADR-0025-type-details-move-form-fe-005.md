# ADR-0025: Карточка типа — отображение counts и форма перемещения (FE-005)

## Статус
Принято

## Контекст
Задача FE-005 требует реализации экрана карточки типа с отображением текущих counts по стадиям и формой перемещения миниатюр вперёд по pipeline. DoD: невозможные переходы недоступны в UI; валидации на клиенте соответствуют PRD.

Каркас страницы `TypeDetailsPage` был создан ранее (FE-001), но содержал ряд дефектов:
1. Состояние `fromStage` не синхронизировалось с доступными опциями — при загрузке типа, у которого IN_BOX = 0, select показывал несоответствующее значение.
2. При отсутствии доступных для перемещения стадий форма показывала fallback-список всех стадий — создавая иллюзию доступных действий.
3. После успешного перемещения секция истории не обновлялась.

## Решение

1. **Синхронизация `fromStage`**: добавлен `useEffect`, который при изменении `item.counts` автоматически выбирает первую стадию с ненулевым count (исключая DONE). Это гарантирует, что select всегда соответствует доступным опциям.

2. **Empty state для формы перемещения**: когда `availableFrom` пуст (все counts = 0 или всё в DONE), вместо формы отображается информативное сообщение «Нет доступных миниатюр для перемещения» / «No items available for moving» через i18n.

3. **Удалён fallback-список**: dropdown source-стадии теперь показывает только стадии с `count > 0`. Если таких нет — отображается empty state (п. 2).

4. **Обновление истории после move**: `HistorySection` принимает `refreshKey` prop и перезагружает данные после каждого перемещения.

## Альтернативы
- **Оставить fallback-список и просто дизейблить кнопку**: проще, но противоречит DoD («невозможные переходы недоступны в UI»), пользователь видит активную форму и не понимает, почему кнопка неактивна.
- **Не обновлять историю после move**: формально FE-006 scope, но пользователь ожидает увидеть запись сразу после действия — потенциальный UX-дефект.

## Последствия
- Форма перемещения корректно отражает доступные действия в любом состоянии данных.
- i18n-словари расширены ключом `moveNoAvailable`.
- CSS дополнен утилитарным классом `.section-empty` для пустых состояний внутри секций.
